spring:
  application:
    name: rulex-fraud-detection

  threads:
    virtual:
      enabled: true

  data:
    redis:
      host: ${SPRING_DATA_REDIS_HOST:localhost}
      port: ${SPRING_DATA_REDIS_PORT:6379}
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 2

  neo4j:
    uri: ${RULEX_NEO4J_URI:bolt://localhost:7687}
    authentication:
      username: ${RULEX_NEO4J_USERNAME:neo4j}
      password: ${RULEX_NEO4J_PASSWORD:}

  datasource:
    url: ${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/rulex_db}
    username: ${SPRING_DATASOURCE_USERNAME:}
    password: ${SPRING_DATASOURCE_PASSWORD:}
    driver-class-name: org.postgresql.Driver
    # HikariCP Connection Pool Configuration
    # PERF-001 FIX: Reduzido pool de 100→30 para evitar exaustão do PostgreSQL
    # PostgreSQL default max_connections=100, múltiplas instâncias precisam compartilhar
    # Recomendação: Use PgBouncer para connection pooling em produção
    hikari:
      pool-name: RulexHikariPool
      # PERF-001: Valores otimizados - fórmula: (core_count * 2) + effective_spindle_count
      minimum-idle: ${HIKARI_MIN_IDLE:5}
      maximum-pool-size: ${HIKARI_MAX_POOL_SIZE:20}
      idle-timeout: ${HIKARI_IDLE_TIMEOUT:300000}
      max-lifetime: ${HIKARI_MAX_LIFETIME:1800000}
      connection-timeout: ${HIKARI_CONNECTION_TIMEOUT:5000}
      leak-detection-threshold: ${HIKARI_LEAK_DETECTION:60000}
      # Validation query for PostgreSQL
      connection-test-query: SELECT 1
      # Auto-commit disabled for transaction management
      auto-commit: false
      # Register MBeans for JMX monitoring
      register-mbeans: true

  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
        use_sql_comments: true
    show-sql: false

  jackson:
    deserialization:
      fail-on-unknown-properties: true
    serialization:
      write-dates-as-timestamps: false
      indent-output: true
    default-property-inclusion: non_null

  flyway:
    enabled: true
    locations: classpath:db/migration

server:
  port: 8080
  servlet:
    context-path: /api

logging:
  level:
    root: INFO
    com.rulex: INFO
    org.springframework.web: INFO
    org.hibernate.SQL: INFO
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"

management:
  endpoints:
    web:
      exposure:
        include: health,prometheus,metrics,info
  endpoint:
    health:
      probes:
        enabled: true
      # SEC-001 FIX: Detalhes do health check apenas para usuários autenticados
      # Em produção, evita expor informações sensíveis sobre infraestrutura
      # Valores: never | when_authorized | always
      show-details: ${ACTUATOR_HEALTH_SHOW_DETAILS:when_authorized}
      show-components: ${ACTUATOR_HEALTH_SHOW_COMPONENTS:when_authorized}
  health:
    neo4j:
      # INFRA-001 FIX: Habilitado health check do Neo4j para detecção de falhas
      enabled: true
    redis:
      # FASE-1 FIX: Habilitado health check do Redis
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
    distribution:
      percentiles-histogram:
        http.server.requests: true
      percentiles:
        http.server.requests: 0.5, 0.95, 0.99
  # OpenTelemetry Tracing
  tracing:
    sampling:
      probability: ${OTEL_SAMPLING_PROBABILITY:1.0}
    propagation:
      type: w3c

# OpenTelemetry Configuration
otel:
  exporter:
    otlp:
      endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT:http://localhost:4318}
      protocol: ${OTEL_EXPORTER_OTLP_PROTOCOL:http/protobuf}
  resource:
    attributes:
      service.name: ${spring.application.name}
      service.version: 1.0.0
      deployment.environment: ${SPRING_PROFILES_ACTIVE:dev}

# RULEX Configuration
rulex:
  rules:
    enabled: true
    cache-enabled: true
  rawPayloadCapture:
    enabled: ${RULEX_RAW_PAYLOAD_CAPTURE_ENABLED:true}
  engine:
    optimizedRuleOrder: false
    bloomFilter:
      enabled: true
    shadowMode:
      enabled: true
    impossibleTravel:
      # GAP-002 FIX: Habilitado via variável de ambiente (default: true para staging/prod)
      # Detecta viagens fisicamente impossíveis entre transações consecutivas
      # Thresholds configuráveis em rulex.fraud.impossible-travel-*
      enabled: ${RULEX_IMPOSSIBLE_TRAVEL_ENABLED:true}
    velocity:
      redis:
        # GAP-FIX #2: Habilitado para performance - usa cache em memória com sliding windows
        # Reduz latência de queries de agregação de ~50ms para <1ms
        enabled: true
  # FASE 2: Configuração de TTLs para RedisCacheManager (@Cacheable)
  redis-cache:
    key-prefix: "rulex:cache:"
    ttl:
      default: 3600        # 1 hora padrão
      bin-lookup: 86400    # 24h - dados estáticos de BIN
      mcc-category: 86400  # 24h - categorias MCC
      geo-reference: 86400 # 24h - dados geográficos
      rules: 300           # 5min - regras podem mudar
      high-risk-mcc: 43200 # 12h - MCCs de alto risco
  # V5.0: Neo4j Graph Tracking para detecção de fraud rings
  neo4j:
    graph-tracking:
      # Habilita gravação de transações no grafo Neo4j para análise de redes de fraude
      # Permite detecção de WCC, PageRank, Louvain clustering, etc.
      enabled: ${RULEX_NEO4J_GRAPH_TRACKING_ENABLED:true}
  audit:
    enabled: true
    # ATENÇÃO: Em produção com alto TPS, considere desabilitar ou usar sampling
    log-all-decisions: ${RULEX_AUDIT_LOG_ALL:false}
  access-log:
    enabled: ${RULEX_ACCESS_LOG_ENABLED:true}
    # GAP-011 FIX: Aumentado sampling rate de 10% para 25% para melhor debugging
    # Sampling rate para logs de sucesso (0.0 = nenhum, 1.0 = todos)
    # Erros (4xx/5xx) e mutações (POST/PUT/DELETE) são sempre logados
    success-sampling-rate: ${RULEX_ACCESS_LOG_SAMPLING:0.25}
    retention-days: ${RULEX_ACCESS_LOG_RETENTION_DAYS:30}
    cleanup-enabled: ${RULEX_ACCESS_LOG_CLEANUP_ENABLED:true}
  retention:
    enabled: ${RULEX_RETENTION_ENABLED:true}
    audit-log-days: ${RULEX_AUDIT_LOG_RETENTION_DAYS:90}
    audit-log-cleanup-enabled: ${RULEX_AUDIT_LOG_CLEANUP_ENABLED:true}
    decision-days: ${RULEX_DECISION_RETENTION_DAYS:90}
    decision-cleanup-enabled: ${RULEX_DECISION_CLEANUP_ENABLED:true}
    raw-payload-days: ${RULEX_RAW_PAYLOAD_RETENTION_DAYS:30}
    raw-payload-cleanup-enabled: ${RULEX_RAW_PAYLOAD_CLEANUP_ENABLED:true}
    homolog-audit-days: ${RULEX_HOMOLOG_AUDIT_RETENTION_DAYS:30}
    homolog-audit-cleanup-enabled: ${RULEX_HOMOLOG_AUDIT_CLEANUP_ENABLED:true}
    homolog-decision-days: ${RULEX_HOMOLOG_DECISION_RETENTION_DAYS:30}
    homolog-decision-cleanup-enabled: ${RULEX_HOMOLOG_DECISION_CLEANUP_ENABLED:true}
    rule-exec-details-days: ${RULEX_RULE_EXEC_DETAILS_RETENTION_DAYS:30}
    rule-exec-details-cleanup-enabled: ${RULEX_RULE_EXEC_DETAILS_CLEANUP_ENABLED:true}
  security:
    enabled: ${RULEX_SECURITY_ENABLED:true}
    admin:
      username: ${RULEX_ADMIN_USERNAME:}
      password: ${RULEX_ADMIN_PASSWORD:}
    analyst:
      username: ${RULEX_ANALYST_USERNAME:}
      password: ${RULEX_ANALYST_PASSWORD:}
  # Rate limiting configuration (Bucket4j token bucket)
  rate-limit:
    enabled: ${RULEX_RATE_LIMIT_ENABLED:true}
    requests-per-minute: ${RULEX_RATE_LIMIT_RPM:100}
    burst-capacity: ${RULEX_RATE_LIMIT_BURST:20}
  # Neo4j Graph Database Configuration
  neo4j:
    enabled: ${RULEX_NEO4J_ENABLED:true}
    uri: ${RULEX_NEO4J_URI:bolt://localhost:7687}
    username: ${RULEX_NEO4J_USERNAME:neo4j}
    password: ${RULEX_NEO4J_PASSWORD:}
    connection-timeout-ms: ${RULEX_NEO4J_CONNECTION_TIMEOUT_MS:2000}
    acquire-timeout-ms: ${RULEX_NEO4J_ACQUIRE_TIMEOUT_MS:2000}
    max-pool-size: ${RULEX_NEO4J_MAX_POOL_SIZE:30}
    max-connection-lifetime-ms: ${RULEX_NEO4J_MAX_CONN_LIFETIME_MS:600000}
    query-timeout-ms: ${RULEX_NEO4J_QUERY_TIMEOUT_MS:2000}

  # QUAL-002 FIX: Configurações externalizadas (substitui magic numbers)
  limits:
    max-request-body-size: ${RULEX_MAX_REQUEST_BODY_SIZE:1000000}
    max-rules-per-transaction: ${RULEX_MAX_RULES_PER_TX:100}
    max-conditions-per-rule: ${RULEX_MAX_CONDITIONS_PER_RULE:50}
    max-nested-groups: ${RULEX_MAX_NESTED_GROUPS:5}
    rule-evaluation-timeout-ms: ${RULEX_RULE_EVAL_TIMEOUT_MS:5000}
  velocity:
    threshold5min: ${RULEX_VELOCITY_5MIN:3}
    threshold1hour: ${RULEX_VELOCITY_1HOUR:10}
    threshold-daily: ${RULEX_VELOCITY_DAILY:50}
    distinct-merchants-threshold: ${RULEX_DISTINCT_MERCHANTS:10}
    distinct-countries-threshold: ${RULEX_DISTINCT_COUNTRIES:5}
    max-devices-per-card: ${RULEX_MAX_DEVICES_PER_CARD:5}
  fraud:
    high-risk-amount-threshold: ${RULEX_HIGH_RISK_AMOUNT:10000.0}
    impossible-travel-distance-km: ${RULEX_IMPOSSIBLE_TRAVEL_KM:500}
    impossible-travel-time-minutes: ${RULEX_IMPOSSIBLE_TRAVEL_MIN:60}
    min-device-trust-score: ${RULEX_MIN_DEVICE_TRUST:50}
    amount-deviation-percent-threshold: ${RULEX_AMOUNT_DEVIATION_PCT:300}
  cache:
    rules-cache-ttl-seconds: ${RULEX_RULES_CACHE_TTL:300}
    velocity-cache-ttl-seconds: ${RULEX_VELOCITY_CACHE_TTL:30}
    velocity-cache-max-size: ${RULEX_VELOCITY_CACHE_SIZE:10000}
    bin-cache-ttl-seconds: ${RULEX_BIN_CACHE_TTL:3600}
  # GAP-007 FIX: Configuração de Webhooks com retry habilitado
  webhook:
    enabled: ${RULEX_WEBHOOK_ENABLED:true}
    timeout-seconds: ${RULEX_WEBHOOK_TIMEOUT:10}
    max-retries: ${RULEX_WEBHOOK_MAX_RETRIES:3}
    retry-backoff-ms: ${RULEX_WEBHOOK_RETRY_BACKOFF:500}

# GAP-E: Configuração SpringDoc OpenAPI
springdoc:
  api-docs:
    enabled: true
    path: /api/v3/api-docs
  swagger-ui:
    enabled: true
    path: /api/swagger-ui.html
    tags-sorter: alpha
    operations-sorter: alpha
  packages-to-scan: com.rulex.controller
  paths-to-match: /**

# Resilience4j Configuration - Circuit Breaker, Retry, Time Limiter
# REFACTOR-001: Adicionado para resiliência do Neo4j e outros serviços externos
resilience4j:
  circuitbreaker:
    instances:
      neo4j:
        slidingWindowType: COUNT_BASED
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        failureRateThreshold: 50
        waitDurationInOpenState: 30s
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        recordExceptions:
          - java.io.IOException
          - java.util.concurrent.TimeoutException
          - org.neo4j.driver.exceptions.ServiceUnavailableException
        ignoreExceptions:
          - java.lang.IllegalArgumentException
      redis:
        slidingWindowType: COUNT_BASED
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        failureRateThreshold: 50
        waitDurationInOpenState: 20s
        permittedNumberOfCallsInHalfOpenState: 3
  retry:
    instances:
      neo4j:
        maxAttempts: 3
        waitDuration: 500ms
        enableExponentialBackoff: true
        exponentialBackoffMultiplier: 2
        retryExceptions:
          - java.io.IOException
          - java.util.concurrent.TimeoutException
        ignoreExceptions:
          - java.lang.IllegalArgumentException
      redis:
        maxAttempts: 2
        waitDuration: 200ms
  timelimiter:
    instances:
      neo4j:
        timeoutDuration: 2s
        cancelRunningFuture: true
      redis:
        timeoutDuration: 1s
        cancelRunningFuture: true
